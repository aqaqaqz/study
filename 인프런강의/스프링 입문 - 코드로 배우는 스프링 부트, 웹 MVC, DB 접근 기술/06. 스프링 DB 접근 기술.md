# 스프링 DB 접근 기술
- H2 Database
    - 가볍고 편리해서 개발이나 테스트 용도로 좋음
    - 웹 화면 제공
    - Download 후 맥은 sh 실행, window는 설치 후 h2 찾아서 실행
        - 가끔 ip가 박히고 못찾는경우 있는데 localhost로 주소 변경
        - JDBC URL : 만들 db 파일 경로
        - 경로의 맨 마지막이 만들어질 파일 이름
        - 파일로 만들어서 접근하면 충돌날수 있음
            - jdbc:h2:tcp://localhost/[경로]
    ~~~
            drop table if exists member CASCADE;
            create table member
            (
                    id bigint generated by default as identity,
                    name varchar(255),
                    primary key (id)
            );
    ~~~
            
- db 설정
    - gradle에 h2 라이브러리 추가
    ~~~
    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	runtimeOnly 'com.h2database:h2' // h2클라이언트
    ~~~
    - application.properties에 아래내용 추가(2.4부터 uername필수)
    ~~~
    spring.datasource.url= jdbc:h2:tcp://localhost/C:/Users/lsh/Desktop/dev/db/h2/file/test
    spring.datasource.driver-class-name=org.h2.Driver
    spring.datasource.username=sa
    ~~~
        
    - JdbcMemberRepository.java
        - 내용은 코드 참조

- 스프링의 장점
    - 강의처럼 메모리->RDB로 바꾸려면 참사가 벌어짐
    - 여기전 해당 Repository만 새로 만들어서 return 시켜주면 작업이 끝남

- 개방-폐쇄원칙(OCP, Open-Closed Principle)
    - 확장에는 열여있고, 변경에는 닫혀있다
    - 객체지향을 잘 활용하면 이게 가능하다
    - 스프링의 DI를 사용하면 '기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경 가능'

- 통합테스트
    - 지금까지는 스프링과 관계없는 자바 내용만을 테스트
    - @SpringBootTest
        - 스프링 컨테이너와 테스트를 함께 실행한다
    - @Transactional
        - 트랙잰션 덕분에 AfterEach, BeforeEach 사용 X
        - 단위는 각 테스트 마다 적용
    - @Commit
        - 달아주면 걍 Commit찍어버림
    - 생성자로 할것 없이 보통 @Autowired 사용
    - 보통 로컬에 DB를 따로 두고서 테스트 한다
    - 통합테스트가 좋은것이냐?
        - 스프링까지 올려서 통합테스트가 필요한 경우도 있지만 이건 잘못된 설계
        - 처음 자바로 작성했던 단위테스트가 좋은 테스트케이스

- 스프링 JDBC Templete
    - 스프링 JdctTemplate과 MyBatis같은 라이브러리는 JDBC API에서 본 반복코드를 대부분 제거해준다
        - 반복코드 : ResultSet 같은놈들
    - SQL은 직접 작성

- JPA
    - 반복 코드 제거에 기본적인 SQL도 JPA로 만들어 실행이 가능
    - SQL과 데이터 중심의 설계에서 객체 중심의 설계로 개발이 가능하다
    - 개발 생산성도 올라감
    - 마이바티스랑 점유율만 비교해 봐도 글로벌하게 사용중
    - 자동으로 테이블도 생성해준다
        - spring.jpa.hibernate.ddl-auto=none
        - 여기선 만든다음 사용하기 때문에 사용X
    - JPA는 인터페이스고 하이버네이트가 구현체
        - 업체마다 맞는거 사용
    - JPA는 항상 Transactional에서 실행
    - 실무에서 진짜 쓸수있을까 하는 의문?
        - 이미 대규모 트래픽 다루는곳에서 사용중

- Spring Data JPA
    - JPA를 편하게 사용하도록 도와주는 기술
    - 반복적인 CRUD를 제공
        - 핵심 비즈니스 로직 개발에 집중 가능하다
    - JPA를 공부한뒤에 하는것을 추천
    - JpaRepository만 상속받는 interface만 만들어주면 끝
        - 알아서 구현체를 만들어준다
    - JpaRepository에 들어가보면 구현되있는 기본적인 제공함수를 볼수있음
        - findById, findAll 등 등
    - 공용으로 불가능한건 당연히 구현해줘야함
        - 이것도 규칙이 있다
        - findByName(String name) => select m from Member m where m.name = ?
        - findByNameAndId(String name) => select m from Member m where m.name = ? and m.id = ?
        - 위와같이 interface만 잘 사용해도 간단한 내용은 구현할 필요가 없다
    - 복잡한 동적쿼리는 Querydsl을 사용하면 자바 코드로 편리하게 작성가능
        - 이것조차 안되면 그냥 네이티브 쿼리도 가능하다

